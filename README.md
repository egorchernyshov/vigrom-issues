# Ответы

Вопросы не тривиальные, а них нет одного простого ответа, можно сделать по-разному в зависимости от условий.

https://docs.google.com/document/d/1nayGeHpFhRfoz3sW1GQkNpXny-3V-nuDU6unMemHYAc

## Задание 1

Таблицы, данные и запрос для удобства размещены в одном файле [chess_tournament.sql](1_sql_chess_tournament/chess_tournament.sql).

Для проверки приложен файл [docker-compose.yml](1_sql_chess_tournament/docker-compose.yml) с сервисом PostrgeSQL базы.

## Задание 2

У меня нет опыта решения подобной задачи таким образом, чтобы на практике узнать, что является главным, а что второстепенным. Я думаю, что логирование задача в принципе не тривиальная и сильно зависит от устройства проекта и окружения.

### Какие я вижу проблемы:
- Уровень детальности 1 секунда. Может случиться так, что все параметры совпадут и запросы придут с промежутком в доли секунды, тогда идентифицировать однозначно их уже нельзя.
- Отсутствие часового пояса тоже возможная проблема с поиском.
- Логирование всегда подразумевает ротацию. Если просто писать логи в базу, то она довольно быстро будет разрастаться, поэтому ей не хватает механизма удаления старых записей.
- В целом это выходит довольно нагруженное мероприятие, требующее отдельной базы, чтобы не навредить более важным основным данным.
- Логируется всё под ряд. Либо подразумевается, что запись в базу происходит, например, с глобального уровня, где отлавливаются какие-то исключения.
- Для php правильнее было бы воспользоваться, например, monolog. Потому что нужно иметь возможность управлять форматированием логов и без изменения всех участков кода логирования можно было сменить место хранения логов, а может и писать сразу в несколько мест.
- Лучше писать в файл, а читать и записывать в базу с индексами, чтобы пользоваться полнотекстовым поиском, тогда это можно делать пачками периодически, а не на каждый запрос. Это требует дополнительного функционала.
- Многое зависит от контекста. Если вдруг окажется, что проект это блог на wordpress, который посещают десять человек в месяц, то и это решение нормальное.

### В общем случае, что бы я переделал:
Внедрил логер типа monolog, чтобы процесс логирования сделать более управляемым и настраиваемым на уровне конфигурации.

Можно использовать сервис [sentry.io](https://sentry.io/). Потому что это правильная мысль развитая до какой-то высокой стадии. Ошибки нужно отлавливать глобально, и логировать отдельно в машиночитаемом виде, чтобы отдельным образом манипулировать с выборкой и представлением результатов в человекочитаемом виде.

Можно использовать ELK (Elasticsearch, Logstash, Kibana) для сбора метрик в целом и ошибок в том числе. Я плохо представляю, как внутри это работает. Знаю, что люди используют NoSQL для логов. Вероятно, за отсутствие связей и произвольность набора полей документа.

## Задание 3

Запросу не хватает транзакции. Между выборкой и обновлением может произойти изменения данных и один запрос перетрёт другой, что-то потеряется. Это зависит от устройства проекта, возможно лучше дополнительно логировать такие операции, чтобы даже если что-то пошло не так, иметь возможность восстановить ход событий и при необходимости какое-то из состояний.

## Задание 4

### Проблемы
- Смешаны два похожих, но самостоятельных функционала: отправки смс и отправки почты.
- Сторонняя библиотека жёстко связана прямым созданием экземпляра класса в конструкторе. Это нельзя покрыть юнит-тестами, потому что нельзя замокать ни отправку почты, ни класс `ThirdPartyLibrary\SMS\SmsService`
- Обе отправки — это сайд-эффект с непредсказуемым поведением. Есть подозрение, что это может создать задержки исполнения кода.

### Плюсы

Плюсы этого кода в его компактности и наглядности. Если проект небольшой и не нагруженный, то этот код годится: он работает и читается.

### Варианты доработки

Вариантов улучшения больше одного, всё зависит от условий.

#### Вариант минимальный.
- Сделать интерфейс `Notification`, который будет иметь метод `notify`
- Разделить этот класс на два `SmsNotification` и `EmailNotification` и реализовать интерфейс `Notification`, таким образом обеспечив потенциальное расширение добавлением очередного отправщика сообщения куда-нибудь ещё.
- В смс-отправщике вынести создание объекта сервиса в отдельный метод, чтобы в тестах его можно было подменять.
- В отправщике почты сделать похожее с методом отправки, вынеся саму отправку в отдельный метод и в тестах подменяя его.

#### Вариант максимальный. Инфраструктурные изменения.
- Нужно иметь контейнер зависимостей и оба сервиса вынести в конфигурацию.
- Для библиотеки отправки СМС нужно сделать адаптер, имплементирующий интерфейс сервисов отправки.
- Нужно иметь очередь событий как отдельный процесс:
  - отправку сообщений помещать в очередь в виде задания,
  - откуда другой процесс забирает задания и выполняет в фоне.
